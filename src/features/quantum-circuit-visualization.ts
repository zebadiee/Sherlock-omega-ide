/**
 * Quantum Circuit Visualization Feature
 * Interactive Bloch sphere and state vector display
 * Generated by Self-Builder Quantum Bot
 */

import { EventEmitter } from 'events';

export interface QuantumState {
  amplitude: [number, number]; // [real, imaginary]
  probability: number;
  phase: number;
}

export interface BlochSphereCoordinates {
  x: number;
  y: number;
  z: number;
  theta: number; // polar angle
  phi: number;   // azimuthal angle
}

export class QuantumCircuitVisualizer extends EventEmitter {
  private canvas: HTMLCanvasElement | null = null;
  private context: CanvasRenderingContext2D | null = null;
  private animationId: number | null = null;

  constructor(canvasId: string) {
    super();
    this.initializeCanvas(canvasId);
  }

  private initializeCanvas(canvasId: string): void {
    this.canvas = document.getElementById(canvasId) as HTMLCanvasElement;
    if (this.canvas) {
      this.context = this.canvas.getContext('2d');
      this.setupEventListeners();
    }
  }

  private setupEventListeners(): void {
    if (this.canvas) {
      this.canvas.addEventListener('click', this.handleCanvasClick.bind(this));
      this.canvas.addEventListener('mousemove', this.handleMouseMove.bind(this));
    }
  }

  public visualizeQuantumState(state: QuantumState): void {
    const blochCoords = this.stateToBlochSphere(state);
    this.renderBlochSphere(blochCoords);
    this.renderStateVector(state);
    this.emit('stateVisualized', { state, blochCoords });
  }

  private stateToBlochSphere(state: QuantumState): BlochSphereCoordinates {
    const [real, imag] = state.amplitude;
    const theta = 2 * Math.acos(Math.abs(real));
    const phi = Math.atan2(imag, real);
    
    return {
      x: Math.sin(theta) * Math.cos(phi),
      y: Math.sin(theta) * Math.sin(phi),
      z: Math.cos(theta),
      theta,
      phi
    };
  }

  private renderBlochSphere(coords: BlochSphereCoordinates): void {
    if (!this.context || !this.canvas) return;

    const ctx = this.context;
    const centerX = this.canvas.width / 2;
    const centerY = this.canvas.height / 2;
    const radius = Math.min(centerX, centerY) * 0.8;

    // Clear canvas
    ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

    // Draw sphere outline
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
    ctx.stroke();

    // Draw axes
    this.drawAxes(ctx, centerX, centerY, radius);

    // Draw state vector
    const stateX = centerX + coords.x * radius;
    const stateY = centerY - coords.z * radius; // Flip Y for screen coordinates
    
    ctx.strokeStyle = '#ff4444';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(centerX, centerY);
    ctx.lineTo(stateX, stateY);
    ctx.stroke();

    // Draw state point
    ctx.fillStyle = '#ff4444';
    ctx.beginPath();
    ctx.arc(stateX, stateY, 6, 0, 2 * Math.PI);
    ctx.fill();
  }

  private drawAxes(ctx: CanvasRenderingContext2D, centerX: number, centerY: number, radius: number): void {
    ctx.strokeStyle = '#666';
    ctx.lineWidth = 1;
    
    // X axis
    ctx.beginPath();
    ctx.moveTo(centerX - radius, centerY);
    ctx.lineTo(centerX + radius, centerY);
    ctx.stroke();
    
    // Y axis (Z in 3D)
    ctx.beginPath();
    ctx.moveTo(centerX, centerY - radius);
    ctx.lineTo(centerX, centerY + radius);
    ctx.stroke();

    // Labels
    ctx.fillStyle = '#666';
    ctx.font = '12px Arial';
    ctx.fillText('|0⟩', centerX - 15, centerY - radius - 10);
    ctx.fillText('|1⟩', centerX - 15, centerY + radius + 20);
    ctx.fillText('|+⟩', centerX + radius + 10, centerY + 5);
    ctx.fillText('|-⟩', centerX - radius - 20, centerY + 5);
  }

  private renderStateVector(state: QuantumState): void {
    // This would render the state vector information in a separate panel
    this.emit('stateVectorUpdate', {
      amplitude: state.amplitude,
      probability: state.probability,
      phase: state.phase
    });
  }

  private handleCanvasClick(event: MouseEvent): void {
    if (!this.canvas) return;
    
    const rect = this.canvas.getBoundingClientRect();
    const x = event.clientX - rect.left;
    const y = event.clientY - rect.top;
    
    this.emit('canvasClick', { x, y });
  }

  private handleMouseMove(event: MouseEvent): void {
    if (!this.canvas) return;
    
    const rect = this.canvas.getBoundingClientRect();
    const x = event.clientX - rect.left;
    const y = event.clientY - rect.top;
    
    this.emit('mouseMove', { x, y });
  }

  public startAnimation(): void {
    if (this.animationId) return;
    
    const animate = () => {
      // Animation logic for rotating Bloch sphere or evolving states
      this.emit('animationFrame');
      this.animationId = requestAnimationFrame(animate);
    };
    
    this.animationId = requestAnimationFrame(animate);
  }

  public stopAnimation(): void {
    if (this.animationId) {
      cancelAnimationFrame(this.animationId);
      this.animationId = null;
    }
  }

  public destroy(): void {
    this.stopAnimation();
    this.removeAllListeners();
    if (this.canvas) {
      this.canvas.removeEventListener('click', this.handleCanvasClick);
      this.canvas.removeEventListener('mousemove', this.handleMouseMove);
    }
  }
}

export default QuantumCircuitVisualizer;