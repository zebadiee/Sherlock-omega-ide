/**
 * Tests for Quantum Circuit Visualization Feature
 * Generated by Self-Builder Quantum Bot
 */

import QuantumCircuitVisualizer, { QuantumState, BlochSphereCoordinates } from '../quantum-circuit-visualization';

// Mock DOM elements for testing
const mockCanvas = {
  getContext: jest.fn(() => ({
    clearRect: jest.fn(),
    strokeStyle: '',
    lineWidth: 0,
    beginPath: jest.fn(),
    arc: jest.fn(),
    stroke: jest.fn(),
    moveTo: jest.fn(),
    lineTo: jest.fn(),
    fillStyle: '',
    fill: jest.fn(),
    fillText: jest.fn(),
    font: ''
  })),
  addEventListener: jest.fn(),
  removeEventListener: jest.fn(),
  getBoundingClientRect: jest.fn(() => ({
    left: 0,
    top: 0,
    width: 400,
    height: 400
  })),
  width: 400,
  height: 400
};

// Mock document.getElementById
global.document = {
  getElementById: jest.fn(() => mockCanvas)
} as any;

// Mock requestAnimationFrame
global.requestAnimationFrame = jest.fn((cb) => {
  setTimeout(cb, 16);
  return 1;
});

global.cancelAnimationFrame = jest.fn();

// Mock MouseEvent for Node.js environment
global.MouseEvent = class MockMouseEvent {
  clientX: number;
  clientY: number;
  type: string;
  
  constructor(type: string, options: { clientX: number; clientY: number }) {
    this.type = type;
    this.clientX = options.clientX;
    this.clientY = options.clientY;
  }
} as any;

describe('QuantumCircuitVisualizer', () => {
  let visualizer: QuantumCircuitVisualizer;

  beforeEach(() => {
    jest.clearAllMocks();
    visualizer = new QuantumCircuitVisualizer('test-canvas');
  });

  afterEach(() => {
    visualizer.destroy();
  });

  describe('Initialization', () => {
    test('should initialize with canvas element', () => {
      expect(document.getElementById).toHaveBeenCalledWith('test-canvas');
      expect(mockCanvas.getContext).toHaveBeenCalledWith('2d');
    });

    test('should set up event listeners', () => {
      expect(mockCanvas.addEventListener).toHaveBeenCalledWith('click', expect.any(Function));
      expect(mockCanvas.addEventListener).toHaveBeenCalledWith('mousemove', expect.any(Function));
    });
  });

  describe('Quantum State Visualization', () => {
    test('should visualize quantum state |0⟩', () => {
      const state: QuantumState = {
        amplitude: [1, 0],
        probability: 1,
        phase: 0
      };

      const eventSpy = jest.fn();
      visualizer.on('stateVisualized', eventSpy);

      visualizer.visualizeQuantumState(state);

      expect(eventSpy).toHaveBeenCalledWith({
        state,
        blochCoords: expect.objectContaining({
          x: expect.any(Number),
          y: expect.any(Number),
          z: expect.any(Number),
          theta: expect.any(Number),
          phi: expect.any(Number)
        })
      });
    });

    test('should visualize quantum state |+⟩ (superposition)', () => {
      const state: QuantumState = {
        amplitude: [1/Math.sqrt(2), 1/Math.sqrt(2)],
        probability: 0.5,
        phase: 0
      };

      const eventSpy = jest.fn();
      visualizer.on('stateVisualized', eventSpy);

      visualizer.visualizeQuantumState(state);

      expect(eventSpy).toHaveBeenCalled();
      const { blochCoords } = eventSpy.mock.calls[0][0];
      
      // |+⟩ state should be on the X-axis of Bloch sphere
      expect(Math.abs(blochCoords.z)).toBeCloseTo(0, 2);
      expect(blochCoords.x).toBeGreaterThan(0);
    });

    test('should convert state to Bloch sphere coordinates correctly', () => {
      const state: QuantumState = {
        amplitude: [0, 1], // |1⟩ state
        probability: 1,
        phase: Math.PI/2
      };

      visualizer.visualizeQuantumState(state);

      // |1⟩ state should be at south pole of Bloch sphere
      const eventSpy = jest.fn();
      visualizer.on('stateVisualized', eventSpy);
      visualizer.visualizeQuantumState(state);
      
      if (eventSpy.mock.calls.length > 0) {
        const { blochCoords } = eventSpy.mock.calls[0][0];
        expect(blochCoords.z).toBeCloseTo(-1, 2);
      }
    });
  });

  describe('Animation', () => {
    test('should start animation', () => {
      visualizer.startAnimation();
      expect(requestAnimationFrame).toHaveBeenCalled();
    });

    test('should stop animation', () => {
      visualizer.startAnimation();
      visualizer.stopAnimation();
      expect(cancelAnimationFrame).toHaveBeenCalled();
    });

    test('should emit animation frame events', (done) => {
      visualizer.on('animationFrame', () => {
        visualizer.stopAnimation();
        done();
      });
      
      visualizer.startAnimation();
    });
  });

  describe('Event Handling', () => {
    test('should handle canvas click events', () => {
      const eventSpy = jest.fn();
      visualizer.on('canvasClick', eventSpy);

      // Simulate click event
      const clickEvent = new MouseEvent('click', {
        clientX: 100,
        clientY: 150
      });

      // Mock getBoundingClientRect
      mockCanvas.getBoundingClientRect = jest.fn(() => ({
        left: 10,
        top: 20,
        width: 400,
        height: 400
      }));

      // Trigger the event handler directly since we can't dispatch real events in tests
      const clickHandler = mockCanvas.addEventListener.mock.calls.find(
        call => call[0] === 'click'
      )[1];
      
      clickHandler(clickEvent);

      expect(eventSpy).toHaveBeenCalledWith({
        x: 90, // 100 - 10
        y: 130  // 150 - 20
      });
    });

    test('should handle mouse move events', () => {
      const eventSpy = jest.fn();
      visualizer.on('mouseMove', eventSpy);

      const moveEvent = new MouseEvent('mousemove', {
        clientX: 200,
        clientY: 250
      });

      mockCanvas.getBoundingClientRect = jest.fn(() => ({
        left: 10,
        top: 20,
        width: 400,
        height: 400
      }));

      const moveHandler = mockCanvas.addEventListener.mock.calls.find(
        call => call[0] === 'mousemove'
      )[1];
      
      moveHandler(moveEvent);

      expect(eventSpy).toHaveBeenCalledWith({
        x: 190, // 200 - 10
        y: 230  // 250 - 20
      });
    });
  });

  describe('Cleanup', () => {
    test('should clean up resources on destroy', () => {
      visualizer.startAnimation();
      visualizer.destroy();

      expect(cancelAnimationFrame).toHaveBeenCalled();
      expect(mockCanvas.removeEventListener).toHaveBeenCalledWith('click', expect.any(Function));
      expect(mockCanvas.removeEventListener).toHaveBeenCalledWith('mousemove', expect.any(Function));
    });
  });

  describe('State Vector Updates', () => {
    test('should emit state vector updates', () => {
      const eventSpy = jest.fn();
      visualizer.on('stateVectorUpdate', eventSpy);

      const state: QuantumState = {
        amplitude: [0.6, 0.8],
        probability: 0.64,
        phase: Math.PI/4
      };

      visualizer.visualizeQuantumState(state);

      expect(eventSpy).toHaveBeenCalledWith({
        amplitude: [0.6, 0.8],
        probability: 0.64,
        phase: Math.PI/4
      });
    });
  });
});